<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Life Event Viewer (Enhanced)</title>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.180.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/"
            }
        }
    </script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #111;
            font-family: 'Inter', sans-serif;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            /* Let clicks pass through, but children can override */
        }

        /* Enable interaction on dots */
        .interactive-dot {
            pointer-events: auto;
            cursor: pointer;
            transition: r 0.2s ease, fill 0.2s ease;
        }

        .interactive-dot:hover {
            r: 6;
            fill: #fff;
        }

        #labels-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
        }

        .label {
            position: absolute;
            background: rgba(10, 20, 30, 0.6);
            border: 1px solid rgba(79, 172, 254, 0.3);
            box-shadow: 0 0 10px rgba(79, 172, 254, 0.1);
            color: #e0f0ff;
            padding: 10px 14px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: auto;
            transition: all 0.2s ease;
            max-width: 200px;
            backdrop-filter: blur(2px);
            cursor: help;
            z-index: 10;
        }

        /* Dimming class for non-highlighted items */
        .label.dimmed {
            opacity: 0.2;
            z-index: 1;
        }

        .label.active {
            z-index: 20;
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        .label:hover {
            background: rgba(5, 10, 20, 0.95);
            border-color: rgba(79, 172, 254, 0.8);
            box-shadow: 0 0 15px rgba(79, 172, 254, 0.4);
            z-index: 100;
            max-width: 280px;
            transform: scale(1.05);
        }

        .label h4 {
            margin: 0 0 4px 0;
            font-size: 14px;
            color: #4facfe;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .label.active h4 {
            color: #ffd700;
        }

        .label .year {
            font-weight: bold;
            color: #ffd700;
            margin-right: 4px;
        }

        .label .desc {
            display: none;
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 6px;
        }

        .label:hover .desc {
            display: block;
        }

        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 12px;
            z-index: 4;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <svg id="svg-layer"></svg>
    <div id="labels-layer"></div>
    <!-- File Selector -->
    <select id="bio-selector"
        style="position: absolute; top: 20px; right: 20px; z-index: 1000; padding: 10px; background: rgba(0,0,0,0.8); color: white; border: 1px solid #444; border-radius: 4px; cursor: pointer; font-family: sans-serif;">
        <option value="" disabled selected>Loading Biographies...</option>
    </select>

    <div id="controls-info">Left Click: Rotate | Right Click: Pan | Scroll: Zoom</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';

        // --- Configuration ---
        const LABEL_PADDING = 10;
        const LABEL_WIDTH_EST = 200;
        const LABEL_HEIGHT_EST = 60;

        // --- Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // Deep space dark blue/black

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 350);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.getElementById('container').appendChild(renderer.domElement);

        // --- Post Processing (Bloom/Glow) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.4, 0.85);
        bloomPass.threshold = 0.85;
        bloomPass.strength = 0.5;
        bloomPass.radius = 0.4;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const outputPass = new OutputPass();
        composer.addPass(outputPass);

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.5);
        sunLight.position.set(100, 100, 100);
        scene.add(sunLight);

        const fillLight = new THREE.DirectionalLight(0x4facfe, 1.0);
        fillLight.position.set(-100, -50, -100);
        scene.add(fillLight);

        // --- Controls ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.zoomSpeed = 0.2;
        controls.rotateSpeed = 0.4;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.15; // Slow rotation (Majestic)
        controls.minDistance = 110;
        controls.maxDistance = 800;

        // --- Stellar Visuals ---
        function addStars() {
            const starsGeo = new THREE.BufferGeometry();
            const starsCount = 2000;
            const posArray = new Float32Array(starsCount * 3);

            for (let i = 0; i < starsCount * 3; i++) {
                // Random pos between -1000 and 1000
                posArray[i] = (Math.random() - 0.5) * 2000;
            }

            starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            const starsMat = new THREE.PointsMaterial({
                size: 2,
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const starField = new THREE.Points(starsGeo, starsMat);
            scene.add(starField);
        }
        addStars();

        function createLatLonGrid() {
            const radius = 100.5;
            const latSegments = 18;
            const lonSegments = 24;
            const vertices = [];

            // Latitudes (Rings)
            for (let i = 1; i < latSegments; i++) {
                const phi = (i / latSegments) * Math.PI;
                const y = radius * Math.cos(phi);
                const r = radius * Math.sin(phi);
                // Loop
                for (let j = 0; j <= 64; j++) {
                    const theta = (j / 64) * Math.PI * 2;
                    vertices.push(r * Math.cos(theta), y, r * Math.sin(theta));
                    if (j > 0) vertices.push(r * Math.cos(theta), y, r * Math.sin(theta));
                }
            }

            // Longitudes (Meridians)
            for (let i = 0; i < lonSegments; i++) {
                const theta = (i / lonSegments) * Math.PI * 2;
                for (let j = 0; j <= 32; j++) {
                    const phi = (j / 32) * Math.PI;
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    vertices.push(x, y, z);
                    if (j > 0) vertices.push(x, y, z);
                }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            // Dim lines
            const material = new THREE.LineBasicMaterial({
                color: 0x4facfe, // Standard UI Blue (was 0x0088aa Teal)
                transparent: true,
                opacity: 0.05,   // Reduced from 0.08
                blending: THREE.AdditiveBlending,
                depthWrite: false // Prevents sorting artifacts/internal lines appearing solid
            });

            return new THREE.LineSegments(geometry, material);
        }

        // --- Animation Globals ---
        let mixer;
        const clock = new THREE.Clock();
        let pins = [];
        let currentModel = null;
        let labelsLayer = document.getElementById('labels-layer');
        let svgLayer = document.getElementById('svg-layer');

        // --- Interaction State ---
        let hoveredPinIndex = -1;

        // SVG Event Delegation (for dots)
        svgLayer.addEventListener('mousemove', (e) => {
            const target = e.target;
            if (target && target.classList.contains('interactive-dot')) {
                const idx = parseInt(target.dataset.index);
                if (!isNaN(idx)) {
                    hoveredPinIndex = idx;
                    document.body.style.cursor = 'pointer';
                    return;
                }
            }
        });

        svgLayer.addEventListener('mouseout', (e) => {
            if (e.target && e.target.classList.contains('interactive-dot')) {
                hoveredPinIndex = -1;
                document.body.style.cursor = 'default';
            }
        });

        // --- Selection Logic ---
        const selector = document.getElementById('bio-selector');

        // Load Manifest
        fetch('bios_manifest.json')
            .then(res => res.json())
            .then(manifest => {
                selector.innerHTML = '<option value="" disabled>Select Biography...</option>';
                manifest.forEach(item => {
                    const opt = document.createElement('option');
                    opt.value = item.file;
                    opt.textContent = item.name;
                    selector.appendChild(opt);
                });

                // Auto-load
                const urlParams = new URLSearchParams(window.location.search);
                const initialFile = urlParams.get('file') || manifest[0].file;

                selector.value = initialFile;
                loadBio(initialFile);
            })
            .catch(err => {
                console.error("Manifest load error:", err);
                selector.innerHTML = '<option disabled>Error Loading Manifest</option>';
            });

        // Switch Logic
        selector.addEventListener('change', (e) => {
            loadBio(e.target.value);
        });

        // --- Load Model ---
        const loader = new GLTFLoader();

        function loadBio(filename) {
            console.log("Loading Bio:", filename);

            // Cleanup Old
            if (currentModel) {
                scene.remove(currentModel);
                currentModel = null;
            }
            labelsLayer.innerHTML = '';
            svgLayer.innerHTML = '';
            pins = [];
            mixer = null;
            hoveredPinIndex = -1; // Reset selection

            // Load New
            loader.load(filename, (gltf) => {
                const model = gltf.scene;
                currentModel = model;

                scene.add(model);

                // Animation setup
                if (gltf.animations && gltf.animations.length > 0) {
                    mixer = new THREE.AnimationMixer(model);
                    gltf.animations.forEach((clip) => {
                        mixer.clipAction(clip).play();
                    });
                }

                setupSceneNodes(model);

            }, undefined, function (error) {
                console.error('An error occurred loading ' + filename, error);
            });
        }

        function setupSceneNodes(model) {
            let gridAdded = false;
            model.traverse((node) => {
                if (!node.isMesh) return;

                if (!node.geometry.boundingSphere) node.geometry.computeBoundingSphere();
                const radius = node.geometry.boundingSphere.radius;
                const vertexCount = node.geometry.attributes.position ? node.geometry.attributes.position.count : 0;

                // 1. Water Sphere
                if (radius >= 99 && radius < 100.8) {
                    node.visible = false;
                }

                // 2. Land Mesh
                if ((radius >= 100.5 && vertexCount > 500) || vertexCount > 4000 || node.name === 'Land') {
                    node.material = new THREE.MeshStandardMaterial({
                        color: 0x1a5c40,      // Deep Jade
                        emissive: 0x001a10,   // Subtle bioluminescent glow
                        roughness: 0.3,       // Glassy/Polished
                        metalness: 0.4,       // Semi-metallic
                        side: THREE.DoubleSide,
                        transparent: true,    // Enable transparency
                        opacity: 0.85         // "Thick" glass look
                    });
                    node.visible = true;
                    node.renderOrder = 0;

                    // Attach Grid to the first Land node found
                    if (!gridAdded) {
                        const grid = createLatLonGrid();
                        node.add(grid);
                        gridAdded = true;
                    }
                }

                // 3. Setup Pins
                if (radius < 10 && vertexCount < 1000) {
                    if ((node.userData && node.userData.extras && node.userData.extras.type === 'event_pin') || (vertexCount > 50 && vertexCount < 500)) {
                        setupPin(node);
                    }
                }

                // 4. Path
                if (String(node.name).includes('Path')) {
                    node.material.emissive = new THREE.Color(0xffd700);
                    node.material.emissiveIntensity = 1.0;
                }
            });
        }

        function setupPin(mesh) {
            const index = pins.length;

            // Color variation based on index (constellation rainbow)
            const hue = (index * 137.5) % 360; // Golden angle distribution for varied colors
            const color = new THREE.Color().setHSL(hue / 360, 0.8, 0.6);

            // Custom Shader Material for Star Effect
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: color },
                    glowColor: { value: new THREE.Color(0x4facfe) },
                    intensity: { value: 1.0 },
                    cameraPosition: { value: new THREE.Vector3() }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `,
                fragmentShader: `
                    uniform float time;
                    uniform vec3 baseColor;
                    uniform vec3 glowColor;
                    uniform float intensity;
                    uniform vec3 cameraPosition;
                    varying vec3 vNormal;
                    varying vec3 vWorldPosition;
                    
                    void main() {
                        // Fresnel glow effect
                        vec3 viewDirection = normalize(cameraPosition - vWorldPosition);
                        float fresnel = pow(1.0 - abs(dot(viewDirection, vNormal)), 2.0);
                        
                        // Sparkle effect (noise-based)
                        float sparkle = sin(time * 5.0 + vWorldPosition.x * 10.0) * 0.5 + 0.5;
                        sparkle = pow(sparkle, 8.0) * 0.3;
                        
                        // Pulse effect
                        float pulse = sin(time * 2.0) * 0.15 + 0.85;
                        
                        // Combine effects
                        vec3 finalColor = baseColor * (1.0 + sparkle);
                        finalColor += glowColor * fresnel * 0.8;
                        finalColor *= pulse * intensity;
                        
                        gl_FragColor = vec4(finalColor, 1.0);
                    }
                `,
                transparent: false,
                side: THREE.DoubleSide
            });

            mesh.material = starMaterial;

            // Store animation properties
            mesh.userData.starMaterial = starMaterial;
            mesh.userData.rotationSpeed = 0.5 + Math.random() * 1.5;
            mesh.userData.pulseOffset = Math.random() * Math.PI * 2;

            // Label
            const div = document.createElement('div');
            div.className = 'label';
            const data = mesh.userData.extras || { name: 'Event', year: '', description: '' };

            // Format: Clean Name
            let cleanName = (data.name || 'Event').replace(/_/g, ' ').toLowerCase();
            cleanName = cleanName.replace(/\b\w/g, c => c.toUpperCase()); // Title Case

            // Description (Fallback to dummy text if missing)
            const desc = data.description || "Historical event recorded in the archives.";

            div.innerHTML = `
                <h4><span class="year">${data.year || ''}</span> ${cleanName}</h4>
                <div class="desc">${desc}</div>
            `;
            labelsLayer.appendChild(div);

            // Hover Listeners on Label
            div.addEventListener('mouseenter', () => {
                hoveredPinIndex = index;
            });
            div.addEventListener('mouseleave', () => {
                hoveredPinIndex = -1;
            });

            pins.push({
                index: index,
                mesh: mesh,
                div: div,
                anchor: new THREE.Vector3(),
                pos: new THREE.Vector2(),
                velocity: new THREE.Vector2(),
                year: parseInt(data.year) || 0
            });
        }

        // --- Label Layout System ---
        function updateLabels() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const halfW = width / 2;
            const halfH = height / 2;

            // --- DYNAMIC GLOBE TRACKING ---
            // Track the center of the globe (0,0,0) in screen space
            const vCenter = new THREE.Vector3(0, 0, 0);
            vCenter.project(camera);
            const cx = (vCenter.x * halfW) + halfW;
            const cy = -(vCenter.y * halfH) + halfH;

            // Calculate Projected Radius (Distance from Center to Visual Edge)
            // We use the camera's "Right" vector to find a point on the horizon of the sphere
            // that represents its visual radius, regardless of rotation.
            const vRight = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            const vEdge = new THREE.Vector3(0, 0, 0).addScaledVector(vRight, 100.5);
            vEdge.project(camera);

            const vEdgeScreenX = (vEdge.x * halfW) + halfW;
            const vEdgeScreenY = -(vEdge.y * halfH) + halfH;

            let earthRad = Math.hypot(vEdgeScreenX - cx, vEdgeScreenY - cy);
            if (isNaN(earthRad) || earthRad < 1) earthRad = 100; // Fallback

            // Timeline Geometry
            const timelineRad = earthRad * 1.15;
            const bandWidth = 20;
            const bandInner = timelineRad - bandWidth / 2;
            const bandOuter = timelineRad + bandWidth / 2;

            // --- Helper Functions (Scoped Here) ---
            function polarToCartesian(r, angle) {
                if (isNaN(cx) || isNaN(cy)) return { x: 0, y: 0 };
                return {
                    x: cx + (r * Math.cos(angle)),
                    y: cy + (r * Math.sin(angle))
                };
            }

            function drawSector(innerR, outerR, startA, endA, color, opacity) {
                const p1 = polarToCartesian(innerR, startA);
                const p2 = polarToCartesian(outerR, startA);
                const p3 = polarToCartesian(outerR, endA);
                const p4 = polarToCartesian(innerR, endA);

                // Check for NaN path
                if (isNaN(p1.x) || isNaN(p2.x)) return '';

                const largeArc = (endA - startA) > Math.PI ? 1 : 0;

                return `<path d="
                    M ${p1.x} ${p1.y}
                    L ${p2.x} ${p2.y}
                    A ${outerR} ${outerR} 0 ${largeArc} 1 ${p3.x} ${p3.y}
                    L ${p4.x} ${p4.y}
                    A ${innerR} ${innerR} 0 ${largeArc} 0 ${p1.x} ${p1.y}
                    Z" 
                    fill="${color}" fill-opacity="${opacity}" stroke="none" />`;
            }

            // 1. Gather & Sort Visible Pins
            const visiblePins = [];
            pins.forEach(p => {
                const worldPos = new THREE.Vector3();
                p.mesh.getWorldPosition(worldPos);

                // Enhanced animation with shader updates
                const elapsedTime = clock.getElapsedTime();
                const isHovered = (p.index === hoveredPinIndex);

                // Update shader uniforms
                if (p.mesh.userData.starMaterial) {
                    p.mesh.userData.starMaterial.uniforms.time.value = elapsedTime + p.mesh.userData.pulseOffset;
                    p.mesh.userData.starMaterial.uniforms.intensity.value = isHovered ? 1.5 : 1.0;
                    p.mesh.userData.starMaterial.uniforms.cameraPosition.value.copy(camera.position);
                }

                // Rotation animation
                p.mesh.rotation.y += p.mesh.userData.rotationSpeed * 0.01;
                p.mesh.rotation.z = Math.sin(elapsedTime + p.mesh.userData.pulseOffset) * 0.2;

                // Scale pulse (enhanced on hover)
                const pulseSpeed = isHovered ? 4 : 3;
                const pulseAmount = isHovered ? 0.15 : 0.1;
                const pulse = 1 + Math.sin(elapsedTime * pulseSpeed + p.mesh.id) * pulseAmount;
                p.mesh.scale.setScalar(pulse);

                worldPos.project(camera);
                const screenX = (worldPos.x * halfW) + halfW;
                const screenY = -(worldPos.y * halfH) + halfH;

                if (isNaN(screenX) || isNaN(screenY)) {
                    p.div.style.display = 'none';
                    return;
                }
                p.anchor.set(screenX, screenY, 0);
                visiblePins.push(p);
            });
            visiblePins.sort((a, b) => a.year - b.year);

            // 2. TIMELINE & COLLISION LOGIC 
            const svgPaths = [];

            if (pins.length > 0) {
                const allSorted = [...pins].sort((a, b) => a.year - b.year);
                const birthYear = allSorted[0].year;
                const lastPinYear = allSorted[allSorted.length - 1].year;
                const currentYear = new Date().getFullYear();

                // Timeline Scale: Full circle (360°) = 100 years
                // 12 o'clock (top, -90°) = birth (0 years)
                // NOW is calculated dynamically
                const startAngle = -Math.PI / 2; // 12 o'clock

                const getAngle = (year) => {
                    const ageInYears = year - birthYear;
                    // 100 years = 360° (full circle)
                    const angleOffset = (ageInYears / 100) * (Math.PI * 2);
                    return startAngle + angleOffset;
                };

                // Calculate NOW position dynamically
                const currentAge = currentYear - birthYear;
                const nowAngle = getAngle(currentYear);

                // --- Calculate Target Positions & Resolve Collision ---
                const labelHeight = 40;
                const leftSide = [];
                const rightSide = [];

                visiblePins.forEach(p => {
                    const angle = getAngle(p.year);
                    const labelOffset = 50;
                    const rawPos = polarToCartesian(timelineRad + labelOffset, angle);
                    const isLeft = Math.cos(angle) < 0;
                    p.targetPos = new THREE.Vector2(rawPos.x, rawPos.y);
                    p.isLeft = isLeft;
                    p.angle = angle;
                    if (isLeft) leftSide.push(p); else rightSide.push(p);
                });

                const resolveSide = (list) => {
                    if (list.length < 2) return;
                    list.sort((a, b) => a.targetPos.y - b.targetPos.y);
                    for (let i = 1; i < list.length; i++) {
                        const prev = list[i - 1];
                        const curr = list[i];
                        const dist = curr.targetPos.y - prev.targetPos.y;
                        if (dist < labelHeight) {
                            curr.targetPos.y += (labelHeight - dist);
                        }
                    }
                };
                resolveSide(leftSide);
                resolveSide(rightSide);

                // --- Rendering ---
                const hasHover = (hoveredPinIndex !== -1);

                let highlightYear = -1;
                let highlightAge = -1;
                if (hasHover) {
                    const targetPin = pins.find(p => p.index === hoveredPinIndex);
                    if (targetPin) {
                        const targetYear = targetPin.year;
                        highlightYear = Math.round(targetYear / 10) * 10;
                        highlightAge = Math.round((targetYear - birthYear) / 10) * 10;
                    }
                }

                // 1. STRIPED BAND (Decades)
                // Show up to 100 years from birth
                const firstDecade = Math.floor(birthYear / 10) * 10;
                const maxDisplayedYear = birthYear + 100;
                const lastDecade = Math.ceil(maxDisplayedYear / 10) * 10;

                for (let y = firstDecade; y < lastDecade; y += 10) {
                    // Start of decade
                    const yStart = Math.max(birthYear, y);
                    const yEnd = Math.min(maxDisplayedYear, y + 10);

                    if (yStart >= yEnd) continue;

                    const a1 = getAngle(yStart);
                    const a2 = getAngle(yEnd);

                    // Stripe Logic
                    const isEven = (y / 10) % 2 === 0;
                    const opacity = isEven ? 0.15 : 0.05;
                    const color = "#4facfe"; // Blue-ish stripes

                    svgPaths.push(drawSector(bandInner, bandOuter, a1, a2, color, opacity));
                }

                // Add Border Lines to Band (full circle for 100 years)
                const arcStart = getAngle(birthYear);
                const arcEnd = getAngle(birthYear + 100);
                const largeArc = 1; // Always full circle

                // Outer Border
                const pOutStart = polarToCartesian(bandOuter, arcStart);
                const pOutEnd = polarToCartesian(bandOuter, arcEnd);
                svgPaths.push(`<path d="M ${pOutStart.x} ${pOutStart.y} A ${bandOuter} ${bandOuter} 0 ${largeArc} 1 ${pOutEnd.x} ${pOutEnd.y}" stroke="#4facfe" stroke-width="1" stroke-opacity="0.5" fill="none" />`);

                // Inner Border
                const pInStart = polarToCartesian(bandInner, arcStart);
                const pInEnd = polarToCartesian(bandInner, arcEnd);
                svgPaths.push(`<path d="M ${pInStart.x} ${pInStart.y} A ${bandInner} ${bandInner} 0 ${largeArc} 1 ${pInEnd.x} ${pInEnd.y}" stroke="#4facfe" stroke-width="1" stroke-opacity="0.5" fill="none" />`);


                // 2. Decade Ticks (Year) overlay
                for (let y = firstDecade; y <= maxDisplayedYear; y += 10) {
                    const a = getAngle(y);
                    const isHighlight = (y === highlightYear);
                    const tickLen = isHighlight ? 8 : 4;
                    const brightness = isHighlight ? 1.0 : 0.6;
                    const width = isHighlight ? 2 : 1;
                    const color = isHighlight ? '#ffd700' : `rgba(255, 255, 255, ${brightness})`;

                    // Ticks on OUTER rim
                    const p1 = polarToCartesian(bandOuter, a);
                    const p2 = polarToCartesian(bandOuter + tickLen, a);

                    svgPaths.push(`<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${color}" stroke-width="${width}" />`);

                    if (y % 50 === 0 || isHighlight) {
                        const dist = bandOuter + 15 + (isHighlight ? 5 : 0);
                        const pText = polarToCartesian(dist, a);
                        const fontSize = isHighlight ? 12 : 9;
                        const fontWeight = isHighlight ? 'bold' : 'normal';
                        svgPaths.push(`<text x="${pText.x}" y="${pText.y}" fill="${color}" font-size="${fontSize}" font-weight="${fontWeight}" text-anchor="middle" alignment-baseline="middle">${y}</text>`);
                    }
                }

                // 3. Age Scale (Inner Ticks) overlay
                const maxAge = 100; // Always show up to 100 years
                for (let age = 10; age <= maxAge; age += 10) {
                    const y = birthYear + age;
                    const a = getAngle(y);
                    const isHighlight = (age === highlightAge);

                    const brightness = isHighlight ? 1.0 : 0.8;
                    const color = isHighlight ? '#ffffff' : `rgba(255, 215, 0, ${brightness})`;
                    const width = isHighlight ? 2.5 : 1.5;

                    // Ticks on INNER rim
                    const p1 = polarToCartesian(bandInner, a);
                    const p2 = polarToCartesian(bandInner - 5, a);
                    svgPaths.push(`<line x1="${p1.x}" y1="${p1.y}" x2="${p2.x}" y2="${p2.y}" stroke="${color}" stroke-width="${width}" />`);

                    if (age % 20 === 0 || isHighlight) {
                        const fontSize = isHighlight ? 12 : (age % 20 === 0 ? 9 : 0);
                        if (fontSize > 0) {
                            const pText = polarToCartesian(bandInner - 15, a);
                            svgPaths.push(`<text x="${pText.x}" y="${pText.y}" fill="${color}" font-size="${fontSize}" font-weight="${isHighlight ? 'bold' : 'normal'}" text-anchor="middle" alignment-baseline="middle">${age}</text>`);
                        }
                    }
                }

                // NOW Marker
                if (currentAge <= 100) {
                    // Only show NOW if within 100 year range
                    const pNow = polarToCartesian(timelineRad, nowAngle);
                    svgPaths.push(`<circle cx="${pNow.x}" cy="${pNow.y}" r="4" fill="#4facfe" stroke="#fff" stroke-width="1.5" />`);
                    svgPaths.push(`<text x="${pNow.x + 12}" y="${pNow.y}" fill="#4facfe" font-size="11" font-weight="bold" alignment-baseline="middle">NOW</text>`);
                }

                // 4. Pins
                visiblePins.forEach((p) => {
                    const timelinePos = polarToCartesian(timelineRad, p.angle); // Pin on center of band
                    const isHovered = (p.index === hoveredPinIndex);
                    const isDimmed = hasHover && !isHovered;

                    const opacity = isDimmed ? 0.1 : 1.0;
                    const strokeColor = isHovered ? '#ffd700' : 'rgba(79, 172, 254, 0.5)';
                    const strokeWidth = isHovered ? 2.5 : 1;
                    const dotColor = isHovered ? '#ffd700' : '#4facfe';

                    // --- VISIBILITY CHECK ---
                    // Determine if the pin is on the front (visible) side of the globe
                    const worldPos = new THREE.Vector3();
                    p.mesh.getWorldPosition(worldPos);

                    // Vector from camera to pin
                    const camToPin = new THREE.Vector3().subVectors(worldPos, camera.position);
                    // Normal at pin position (sphere centered at origin)
                    const pinNormal = worldPos.clone().normalize();

                    // If dot product is negative, pin is facing away from camera (on back side)
                    const isFrontFacing = camToPin.dot(pinNormal) < 0;

                    const dx = p.anchor.x - cx; // Relative to dynamic center
                    const dy = p.anchor.y - cy;
                    const globeAngle = Math.atan2(dy, dx);

                    let pathD;
                    if (isFrontFacing) {
                        // Pin is visible - use direct routing close to surface
                        const cp2Dist = earthRad + 20;
                        const cp2 = polarToCartesian(cp2Dist, globeAngle);
                        const cp1Dist = bandInner - 30;
                        const cp1 = polarToCartesian(cp1Dist, p.angle);

                        pathD = `M${timelinePos.x},${timelinePos.y} C${cp1.x},${cp1.y} ${cp2.x},${cp2.y} ${p.anchor.x},${p.anchor.y}`;
                    } else {
                        // Pin is on back side - route around the visible edge
                        // Use a higher arc that stays well above the globe's visible silhouette
                        const cp1Dist = timelineRad + 40; // Go outward from timeline
                        const cp1 = polarToCartesian(cp1Dist, p.angle);

                        // CP2: midpoint angle, but much higher to ensure we clear the globe
                        const midAngle = (p.angle + globeAngle) / 2;
                        const cp2Dist = Math.max(timelineRad + 60, earthRad + 80); // Well above surface
                        const cp2 = polarToCartesian(cp2Dist, midAngle);

                        pathD = `M${timelinePos.x},${timelinePos.y} C${cp1.x},${cp1.y} ${cp2.x},${cp2.y} ${p.anchor.x},${p.anchor.y}`;
                    }

                    // Differentiate timeline callouts (dashed) from surface paths (solid)
                    const strokeDashArray = "3,2"; // Dashed for timeline connectors
                    svgPaths.push(`<path d="${pathD}" stroke="${strokeColor}" stroke-width="${strokeWidth}" stroke-dasharray="${strokeDashArray}" fill="none" style="opacity: ${opacity}; transition: opacity 0.2s;" />`);

                    // Dot in middle of band
                    svgPaths.push(`<circle class="interactive-dot" data-index="${p.index}" cx="${timelinePos.x}" cy="${timelinePos.y}" r="${isHovered ? 6 : 4}" fill="${isHovered ? '#fff' : '#ffd700'}" stroke="#000" stroke-width="1" style="opacity: ${opacity > 0.5 ? 1 : 0.3}"/>`);
                    svgPaths.push(`<circle cx="${p.anchor.x}" cy="${p.anchor.y}" r="${isHovered ? 4 : 2}" fill="${dotColor}" style="opacity: ${opacity}"/>`);

                    p.pos.x += (p.targetPos.x - p.pos.x) * 0.1;
                    p.pos.y += (p.targetPos.y - p.pos.y) * 0.1;
                    const xShift = p.isLeft ? '-100%' : '0%';
                    p.div.style.transform = `translate(${p.pos.x}px, calc(${p.pos.y}px - 50%)) translateX(${xShift})`;
                    p.div.style.textAlign = p.isLeft ? 'right' : 'left';
                    p.div.style.marginLeft = p.isLeft ? '-10px' : '10px';

                    if (isHovered) p.div.classList.add('active'); else p.div.classList.remove('active');
                    if (isDimmed) p.div.classList.add('dimmed'); else p.div.classList.remove('dimmed');
                    p.div.style.display = 'block';
                });

                // Ghost Dots
                pins.forEach(p => {
                    const a = getAngle(p.year);
                    const d = polarToCartesian(timelineRad, a);
                    const isHovered = (p.index === hoveredPinIndex);
                    if (!visiblePins.includes(p)) {
                        svgPaths.push(`<circle class="interactive-dot" data-index="${p.index}" cx="${d.x}" cy="${d.y}" r="${isHovered ? 5 : 2}" fill="rgba(255, 255, 255, ${isHovered ? 1 : 0.15})" stroke="none" />`);
                    }
                });
            }
            svgLayer.innerHTML = svgPaths.join('');
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (mixer) mixer.update(delta);

            controls.update();

            // Safety check for updateLabels
            try {
                updateLabels();
            } catch (e) {
                console.warn("Label update error:", e);
            }

            composer.render();
        }

        // --- Resize Handler ---
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            bloomPass.resolution.set(window.innerWidth, window.innerHeight);
        }

        // Start Loop
        animate();
    </script>
</body>

</html>